husky - pre-commit hooks library.
lint-staged - gives ability to manage files that will be in commit
in .eslintrc - we inherit eslint-config-prettier from external package, and react eslint from react. Also, we're adding
a plugin eslint-plugin-prettier so there won't be conflicts between linters - prettier and eslint.

So Redux - one-wayоднонаправленный поток данных в вашем приложении. Случилось
действие от юзера - полетел экшен, экшен был пойман редьюсером - изменились
пропсы у React-компонента -> компонент перерисовался.

Redux - keeps state in one place (store) and has one way data flow: action occurs -> actionCreator creates action object,
reducer catches action object, process it and returned new state of application -> new state of applications means new
props in components -> components rendered with new props.
Redux inspired by Flux, under the hood Redux uses "context" feature of react.
There is old "context" and after the react 16.3 - "New Context API" - be aware.

State - it's a big object with all states of components "Store" is that object. In Redux there is only one Store unlike
Flux. Store join reducers and actions, and has a lot of useful methods like:
getState()
dispatch(action) -> renew state with new action
subscribe(listener)

Actions - it's an object that describes actions, {type: DO_SOME_ACTION, payload: data_that_action_needs} -
type is mandatory, and preferably to store all data that comes with action - in payload. Also with the common rules - we
should keep action types in constants. const DO_SOME_ACTION = 'Some_action_done'
To make action happen - you need actionCreator function.
const DO_SOME_ACTION = 'Some_action_done'
function doSomeAction() {
  return {
    type: DO_SOME_ACTION,
    payload: data_that_action_needs
  }
}

Reducer. Action says "something happened!", but doesn't describes how Store should be changed after something happened.
This is the job of reducer.
There are common approach of "reducer composition". Mean we divide big application state to small pieces, and each
piece - has it's own reducer that responsible for this piece of state. All reducers joins in rootReducer.
From reducer if something changes we need to return only new object of state, never a changed old one.
function pagerReducer(state = initialState, action) {
  if(action.type = DO_SOME_ACTION){
    return Object.assign({}, state, {
       changedStateProperty: action.payload
    })
  } else {
    return state;
  }
}

Redux package:
createStore(reducer, [preloadedState], [enhancer])
Creates a Redux store that holds the complete state tree of your app. There should only be a single store in your app.
reducer (Function): A reducing function that returns the next state tree, given the current state tree and an action
to handle.
[preloadedState] (any): The initial state.
[enhancer] (Function): The store enhancer. You may optionally specify it to enhance the store with third-party
capabilities such as middleware, time travel, persistence, etc.
Returns (Store): An object that holds the complete state of your app. The only way to change its state is by
dispatching actions. You may also subscribe to the changes to its state to update the UI.

React-Redux package components:
Provider - all components inside it can access Store.

To bind redux store with react components props - we need "connect" function. It connects react component with store,
we describe what properties we need to get from store, and pass component we need to pass those properties. It returns
<Connected(My_React_component)/> new component but with bounded props from store.