husky - pre-commit hooks library.
lint-staged - gives ability to manage files that will be in commit
in .eslintrc - we inherit eslint-config-prettier from external package, and react eslint from react. Also, we're adding
a plugin eslint-plugin-prettier so there won't be conflicts between linters - prettier and eslint.

So Redux - one-wayоднонаправленный поток данных в вашем приложении. Случилось
действие от юзера - полетел экшен, экшен был пойман редьюсером - изменились
пропсы у React-компонента -> компонент перерисовался.

Redux - keeps state in one place (store) and has one way data flow: action occurs -> actionCreator creates action object,
reducer catches action object, process it and returned new state of application -> new state of applications means new
props in components -> components rendered with new props.
Redux inspired by Flux, under the hood Redux uses "context" feature of react.
There is old "context" and after the react 16.3 - "New Context API" - be aware.

State - it's a big object with all states of components "Store" is that object. In Redux there is only one Store unlike
Flux. Store join reducers and actions, and has a lot of useful methods like:
getState()
dispatch(action) -> renew state with new action
subscribe(listener)

Actions - it's an object that describes actions, {type: DO_SOME_ACTION, payload: data_that_action_needs} -
type is mandatory, and preferably to store all data that comes with action - in payload. Also with the common rules - we
should keep action types in constants. const DO_SOME_ACTION = 'Some_action_done'
To make action happen - you need actionCreator function.
const DO_SOME_ACTION = 'Some_action_done'
function doSomeAction() {
  return {
    type: DO_SOME_ACTION,
    payload: data_that_action_needs
  }
}
Almost all actions from User on UI - is a dispatch action event.
App has it's initial state ->
User clicks the button, action BUTTON_CLICKED dispatched ->
Button reducer catches the action dispatch and renew state of app ->
Components listened state change - rendered.

Reducer. Action says "something happened!", but doesn't describes how Store should be changed after something happened.
This is the job of reducer.
There are common approach of "reducer composition". Mean we divide big application state to small pieces, and each
piece - has it's own reducer that responsible for this piece of state. All reducers joins in rootReducer.
From reducer if something changes we need to return only new object of state, never a changed old one.
function pagerReducer(state = initialState, action) {
  if(action.type = DO_SOME_ACTION){
    return Object.assign({}, state, {
       changedStateProperty: action.payload
    })
  } else {
    return state;
  }
}

Redux package:
createStore(reducer, [preloadedState], [enhancer])
Creates a Redux store that holds the complete state tree of your app. There should only be a single store in your app.
reducer (Function): A reducing function that returns the next state tree, given the current state tree and an action
to handle.
[preloadedState] (any): The initial state.
[enhancer] (Function): The store enhancer. You may optionally specify it to enhance the store with third-party
capabilities such as middleware, time travel, persistence, etc.
Returns (Store): An object that holds the complete state of your app. The only way to change its state is by
dispatching actions. You may also subscribe to the changes to its state to update the UI.
Simple enhancer - is logger. We can plug it via
import { applyMiddleware } from 'redux';
import { rootReducer } from '../reducers';
export function logger(store) {
  return function(next) {
    return function(action) {
      console.log('Action will be dispatched.');
      console.log(action);
      return next(action);
    };
  };
};
export const store = createStore(rootReducer, applyMiddleware(logger));

Thunk redux - is middleware, enhancer that adds ability to return from action creator not only the object like in sync
actions, but a function that have a dispatch as a parameter, and after some async action in this function - we can
dispatch an event.
function createThunkMiddleware(extraArgument) {
    return ({ dispatch, getState }) => next => action => {
        if (typeof action === 'function') {
            return action(dispatch, getState, extraArgument);
        }
        return next(action);
    };
}
const thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;
export default thunk;

React-Redux package components:
Provider - all components inside it can access Store.

Connect
function connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?)
To bind redux store with react components props - we need "connect" function. It connects react component with store,
we describe what properties we need to get from store, and pass component we need to pass those properties. It returns
<Connected(My_React_component)/> new component but with bounded props from store. Also after wrapping wrapped component
has function dispatch in it's props. In connect function we bind store properties that needed to especially for some
component to this component props and we also automatically subscribe for changes to this properties, mean if something
will change properties in store - component reducer will automatically update component props and component will be
rendered. So we should subscribe only for needed properties in component connect function, otherwise component will be
rendered even when nothing is changed for it.
To bind redux dispatch function to actions from component - we need mapDispatchToProps.


React Component vs Container
- aimed:  Component: How it should look like (markup, styles)
          Container: How it should work (data managing, state setting)
- knows about redux? Component: No Container: Yes
- gets Data from: Component: from props
                  Container: subscribed to redux state changes
- to change data: Component: call callback from props
                  Container: dispatches redux action
- created: Component: by developers, with hands
           Container: generated by Redux (commonly)
