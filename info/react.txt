====================================
Overall:
React killer feature - that it managing virtual DOM, making all changes with components in virtual DOM, and after that
makes all changes in one operations with real DOM, which makes it very fast.

React using the jsx syntax, it gives ability to write a "html" markup (which is jsx markup) in .js files.
To render component from jsx - we should name and call it from capital. ReactDOM.render(<App />, $('#root'))
to ReactDOM.render(<h1>Hello world</h1>... became ReactDOM.render(React.createElement('h1', null, 'Hello world')...
we are using babel, babel makes from jsx markup language - javascript.

====================================
Codding:
React is a library, not a framework, so we can plugin react as a simple <script> to our document like
<script src="https://unpkg.com/react@16/umd/react.development.js"></script> - react
<script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script> - react-dom
<script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script> - babel

After we plugin react - we can use ReactDOM global variable.
ReactDOM.render(<h1>Hello world</h1>, document.getElementById('root'))
ReactDOM.render gets React Component as an argument and DOM-element as element where we want to mount our component.

ReactDOM.render(<h1>Hello world</h1>, document.getElementById('root'));
ReactDOM.render(React.createElement('h1', null, 'Привет, Мир!'), document.getElementById('root'));
If we trying to mount two components to one element - last one will appear.

We can create element from function let App = () => <p>Simple Component</p> and with class
class ComponentFromClass extends React.Component {render(){return (<p>Simple Component</p>)}}
If component created with class - jsx should be putted inside return statement of render "method"

Components created with class - stateful components, with a state, components created with functions - stateless, means
doesn't have a state.

ReactDOM.render(<h1 className="redColor">Hello world</h1>, $('#root'));
Since we writing not html but jsx, and we in .js file - we cannot use html's class="redColor", it's a reserved word, so
we using jsx className.

Each component should return ONE NODE! we cannot return from render(){return (<a/> <p/>)}, we should do:
 return (<div><a/> <p/></div>)
Another way to do that is add multiple components in <React.Fragment> and return it.

Each component has properties, they stored in this.props in stateful components, and first argument of the function in
stateless. They pass to the component as attributes. this.props used only for reading.

<React.Fragment> {/* Comment inside jsx */} </React.Fragment>;

We can easily build page with objects. Like making a long list of paragraphs from array of objects.
const newsTemplate = this.props.news.map((item, index) => {
    return <div key={index}> <p className="news_text">{item.text}</p> </div>;
  });

key={index} - we need key to set unique if to the element. Index is not a best choice, better use element id, or
some hash.

We can decide to return an element like here:
return (<div>{newsAvailable ? <p>News</p> : null}</div>);

Or choose a style for the element with template string:
return (<div>{someElement} <p className={`neededClass ${newsAvailable ? '' : 'optional class'}}>News</p></div>);

Additional methods in React Components we can type like:
renderNews = () => {} -> context isn't lost, we still have access to this.props
renderNews() {} - context lost, React does something with functions - so context lost in this way. To make regular
function declaration work - we need to bind them in constructor of component.
constructor () {this.renderNews = this.renderNews.bind(this)} - looks like shit, but unfortunately no choice.

PropTypes
This is a library for validating component properties. Kind like Joi for mongoose.
MyComponent.propTypes = {optionalArray: PropTypes.array.isRequired}
Note: Doesn't work with production build version, it's only for development, because validation - is a heavy
operation.

MyComponent.propTypes = {
propTypes: {
optionalProperty: PropTypes.array, .bool, .func, .number, .object, .string, .symbol,
optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message)])
optionalObjectWithShape: PropTypes.shape({ color: PropTypes.string.isRequired, fontSize: PropTypes.number})
requiredFunc: React.PropTypes.func.isRequired,
requiredAny: React.PropTypes.any.isRequired,
}

====================================
State
Available only in stateful component.
To work with state-depended properties we should set the "initial state" to them. To do this we should implement the
"state" property. Always change state via this.setState method. Reading this.state after setState() - not a good idea,
because of a queue, you can get state before your previous state change actually fired, better do actions in setState
callback - it will fire after setState fired.
class Article extends React.Component {
    state = {myState: 'initial'}
    handleEvent(e){this.setState({myState: 'changed'}, [() => {/*optional callback or list of callbacks to do stuff
    after state change*/})]}
}
or even
this.setState((state, props) => {counter: state.counter + props.step});
When you changing the state of component - it involves render method of the component which state was changed.
You cannot call setSate() inside render() - recursion will occur.
render - is a pretty heavy operation so try to run it less times.
If parent component re-rendered - all children re-rendered also.

Be careful with setState({prop: this.state.prop}), setState - doesn't change the state immediately, it adds change event
in queue. If you want to reference some value after method fires, it can return previous (past) value.
For example setState({prop: this.state.prop++}) - will never work properly, initial value of prop is 0.
We insert event "change state to {prop: 0}" in queue.
Postponement worked, prop became 1.
change event fired prop is back to 0 again. That's it.

JSX syntax supports a lot of events listeners that you can add to the components.
<a href="#" onClick={this.handleReadMoreClick}>Read more...</a>
event handlers should be done only with arrow function, otherwise context is lost. handleReadMoreClick = (e) => {}

event.target vs event.currentTarget
If you have onClick on div with paragraph inside. And User clicks on paragraph:
e.target === paragraph, the element which caused the event, on what event was born, which user interacted with.
e.currentTarget === div, the element that has handler function registered, which handler was attached to.

Uncontrolled vs controlled component
Controlled - form, input, textarea, select elements usually has their own state, and update depends on user input. This
 doesn't work with logic of components state in React. To make that work in React style - we should delegate to React
 state all changes made by user in those components, so we're like don't allow those elements make their changes by
 themselves, only with our know, and only via state of the component. Elements with their "own" state, that fully
 controlled by React component state called em... controlled.

Uncontrolled component means it has no event/change state handlers, means it doesn't have explicit calls to setState
in front of controlled component.
You need to create reference in Component constructor
constructor(props) {
      super(props);
      this.input = React.createRef()
    }
Than you should set reference to some element via "refs" attribute to get the value of uncontrolled.
<input ref={this.input} defaultValue="Some value..."></input>
And now you can get a value of this input
handleSomeButtonClickFromSameWithInputComponent = (e) => alert(this.input.current.value);

To set initial value for uncontrolled component "defaultValue" can be used.
